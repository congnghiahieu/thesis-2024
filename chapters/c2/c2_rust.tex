\section{Ngôn ngữ lập trình Rust}

\subsection{Giới thiệu tổng quan}

% Rust was first introduced in 2006 by the Mozilla Foundation with its version 1.0 release announced in 2015. The language has since been adopted rapidly, with its strong focus on code safety and high performance comparable to that of C or C++ as the main reasons for its success [35], [46]. Rust features a strong type system and enforces memory safety guarantees, adding to the language’s safety [29]. Guarantees include that there is only one mutable (writeable) reference to an object or several readable ones, but not both at the same time. This ownership system introduces zero runtime overhead as it is enforced at compile time and effectively eliminates a large class of correctness errors many C implementations are suffering from. Classic memory safety bugs that are typically avoided with Rust include buffer overflows, use-after-frees and null pointer dereferences [48]. Using the unsafe keyword, it is still possible to perform potentially unsafe operations where necessary [29], [28]. Raw pointer accesses are one example of an unsafe operation as the borrow checker is not able to reason about these without a type-safe view on the underlying memory. Especially in embedded systems and low-level programming, such operations often are not completely avoidable. Usage of unsafe blocks can often be restricted to very few code sites, e.g., by wrapping unsafe functionality in safe interfaces. Overall, Rust offers full control where needed while still being considerably safer than the alternatives, making it highly suitable for systems programming [27]. Besides C and assembly, it is the only language supported for Linux kernel development

Rust lần đầu tiên được giới thiệu vào năm 2006 bởi Mozilla, với phiên bản 1.0 được công bố vào năm 2015 và nhanh chóng được đem vào sử dụng trong nhiều dự án.
Với điểm mạnh tập trung vào sự an toàn và hiệu suất cao, có thể so sánh với C/C++, là những lý do chính cho sự thành công của Rust \cite{je2020scientists,stackoverflowStackOverflow}.
Rust là ngôn ngữ định kiểu mạnh tương tự như C/C++ hay Java và áp đặt các cơ chế đảm bảo về an toàn bộ nhớ, bổ sung cho sự an toàn của ngôn ngữ này \cite{rustlangRustProgramming}.
Một số tính năng an toàn có thể kể đến như đảm bảo chỉ có một tham chiếu có thể ghi (mutable) tới một đối tượng hoặc nhiều tham chiếu chỉ đọc, nhưng không thể cỏ ghi và đọc cùng 1 lúc.
Cơ chế quản lý bộ nhớ $ownership$ được áp dụng vào thời điểm biên dịch, do đó loại bỏ được một lớp lớn các lỗi bộ nhớ mà C/C++ gặp phải.
Các lỗi về an toàn bộ nhớ cổ điển có thể được tránh bởi việc sử dụng Rust bao gồm tràn bộ đệm (stack-overflow), sử dụng sau khi giải phóng bộ nhớ (use-after-free) và tham chiếu null \cite{googleblogMemorySafe}.
Ngoài các cơ chế đảm bảo an toàn được sử dụng mặc định trong ngôn ngữ, Rust vẫn cho phép viết những đoạn mã code có tiềm năng mất an toàn bằng từ khóa \textit{unsafe} \cite{rustlangRustProgramming}.
Tổng quan, Rust cung cấp cho sự an toàn và quyền kiểm soát khi cần thiết, làm cho nó rất phù hợp cho lập trình hệ thống \cite{jung2021safe}, lập trình nhúng \cite{sharma2023rust}, hay các chương trình du hành ngoài không gian yêu cầu sự an toàn tuyệt đối \cite{seidel2024bringing}.

\subsection{Cơ chế an toàn của Rust}

\begin{listing}[H]
\begin{minted}[mathescape, breaklines, frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{rust}
fn ownership_and_borrowing() -> &u32 {
  // creates a `Vec`, a heap allocated buffer
  let vec = vec![1, 2, 3];

  // creates a reference to the first value with borrowing
  let first_val = &vec[0];

  // Ownership: `Vec` is automatically reclaimed
  // when its owner `vec` goes out of the scope.
  //
  // Borrowing: compile error; Rust prevents `first_val`
  // to outlive `vec` by tracking variable lifetimes.
  return first_val;
}

fn aliasing_xor_mutability() {
  let mut vec = vec![1, 2, 3];

  // exclusive mutable borrowing
  let mut_ref = &mut vec;

  // shared read-only borrowing
  let shared_ref1 = &vec;
  let shared_ref2 = &vec;
  println!("{}", shared_ref1[0]);
  println!("{}", shared_ref2[0]);

  // Exclusive mutability: compile error;
  // Rust invalidates `mut_ref` when `shared_ref1` is
  // used since they cannot coexist at the same time.
  mut_ref.push(4);
}
\end{minted}
\caption{Ví dụ các khái niệm an toàn trong Rust: (1) ownership, (2) borrowing, and (3) Exclusive mutability.}
\label{code:c2_safe_rust}
\end{listing}
Rust là một ngôn ngữ an toàn về kiểu,
được thiết kế cho phát triển phần mềm mức hệ thống,
mang lại cho lập trình viên quyền kiểm soát tối đa với tài nguyên nhưng đảm bảo an toàn bộ nhớ và đa luồng bằng một tập các cơ chế nghiêm ngặt.
Trình biên dịch của Rust sẽ kiểm tra các cơ chế này để loại bỏ các vấn đề nguy hiểm tiềm tàng.
Các cơ chế an toàn bao gồm các khái niệm cơ bản:

\textbf{Ownership}: Cơ chế $ownership$ giúp Rust có sự điều khiển vừa đủ với bộ nhớ, không cần sử dụng bộ thu gom rác (garbage collector) hoặc để người dùng tự xử lý như C/C++.
Theo cơ chế $ownership$ của Rust, một giá trị (vị trí bộ nhớ) chỉ có một chủ sở hữu độc quyền (biến).
Khi chủ sở hữu của giá trị ra khỏi phạm vi cụ thể, giá trị trong bộ nhớ sẽ bị giải phóng.
Gán biến cho 1 biến khác dẫn đến chuyển quyền sở hữu.
Khi một biến mất quyền sở hữu một giá trị, biến đó sẽ không còn sử dụng được.
Trình biên dịch Rust theo dõi tuổi thọ của mỗi giá trị thông qua cơ chế $ownership$ và thực hiện thu hồi bộ nhớ cần thiết.
Cơ chế $ownership$ tương tự như mẫu Resource-Acquisition-Is -Initialization (RAII) \cite{cppreferenceRAIICppreferencecom} thường được sử dụng trong ngôn ngữ C++.

\textbf{Borrowing}: Rust cho phép mượn giá trị (tức là tạo tham chiếu đến nó) trong suốt thời gian sống của biến chủ sở hữu.
Với cơ chế mượn, một giá trị có thể được đọc hoặc cập nhật mà không thay đổi quyền sở hữu của giá trị.
Hệ thống kiểu của Rust đảm bảo rằng các vấn đề an toàn bộ nhớ truyền thống như sử dụng sau khi giải phóng (use-after-free) hoặc con trỏ treo không thể xảy ra bằng cách không cho phép các tham chiếu tồn tại lâu hơn biến chủ sở hữu.

\textbf{Exclusive mutability}: Có hai loại mượn: 1) mượn chia sẻ để đọc và 2) mượn độc quyền để ghi.
Trình biên dịch Rust đảm bảo rằng cả tham chiếu đọc và tham chiếu ghi không bao giờ xuất hiện cùng một lúc.
Điều này có nghĩa là các thao tác đọc và ghi đồng thời là không thể trong Rust, loại bỏ khả năng xảy ra tương tranh với dữ liệu và các lỗi an toàn bộ nhớ như truy cập các tham chiếu không hợp lệ (null-pointer dereferencing).

\textbf{Lifetime}: Lifetime giải thích các phạm vi mà tham chiếu trong chương trình Rust có hiệu lực.
Tính năng lifetime trong Rust bao gồm một loạt các generic cho biết cách các tham chiếu liên quan đến nhau.
Cụ thể, để xác định khi nào các tham chiếu ra khỏi phạm vi, trình biên dịch liên kết mỗi tham chiếu mượn với một lifetime và theo dõi các ràng buộc giữa các tham chiếu.
Lifetime inference đảm bảo rằng thời gian sống của quyền sở hữu mượn sẽ đủ dài để sử dụng.

\textbf{Thread safe}: Lập trình đa luồng trong Rust được đảm bảo an toàn nhờ mô hình $ownership$ và \textit{borrowing}, ngăn chặn tương tranh dữ liệu ngay từ khi biên dịch.

\textbf{Send và Sync Traits}: Rust sử dụng các đặc điểm Send và Sync để đảm bảo an toàn đa luồng ở mức kiểu.
Một kiểu là Send nếu nó có thể được chuyển an toàn giữa các luồng, và Sync nếu nó có thể được chia sẻ an toàn giữa các luồng.
Trình biên dịch Rust sử dụng các đặc điểm này để kiểm tra tại thời điểm biên dịch xem dữ liệu có thể được chia sẻ hoặc di chuyển giữa các luồng một cách an toàn hay không.

\textbf{Mutex và Arc}: Đối với trạng thái có thể thay đổi được chia sẻ, Rust cung cấp các nguyên thủy đồng bộ hóa như Mutex (loại trừ lẫn nhau) và Arc (đếm tham chiếu nguyên tử).
Mutex đảm bảo rằng chỉ có một luồng có thể truy cập dữ liệu tại một thời điểm, ngăn chặn các điều kiện đua.
Arc được sử dụng để đếm tham chiếu an toàn giữa các luồng, cho phép nhiều luồng chia sẻ quyền sở hữu dữ liệu.

\textbf{Ownership Transfer in Threads}: Rust khuyến khích chuyển quyền sở hữu dữ liệu vào các luồng, điều này ngăn chặn trạng thái có thể thay đổi được chia sẻ giữa các luồng.
Khi một luồng được tạo ra, dữ liệu có thể được chuyển vào luồng đó, đảm bảo rằng luồng cha không còn quyền truy cập vào nó, do đó tránh được các điều kiện đua tiềm ẩn.

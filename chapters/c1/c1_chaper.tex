\chapter{Đặt vấn đề}
\label{chap:introduction}

\begin{itemize}
    \item Viết về sự phát triển của Rust trong những năm gần đây, được nhiều công ty lớn sử dụng, có mặt trong nhiều dự án lớn, nhiệm vụ quan trọng (space, web browser, OS, ...)
    \item Rust là một ngôn ngữ lập trình an toàn nên được các công ty lớn ưu tiên sử dụng. Rust cung cấp nhiều cơ chế an toàn như ownership, borrowing, lifetime, type system, ...
    \item Rust là ngôn ngữ lập trình an toàn, tuy nhiên sự an toàn này là không đảm bảo chắc chắn. Rust là ngôn ngữ lập trình nhắm tới system level, và với các cơ chế an toàn của mình, rust có thể giúp tránh được các lỗi về memory safety như buffer overflow, use after free, double free, null pointer dereference, pointer dangling hay các lỗi về đa luồng như data race, deadlock, ...
    \item Dù cung cấp các tính năng bảo mật như vậy nhưng mã nguồn Rust vẫn sẽ tiềm tàng những nguy hiểm. Rust code được chia làm 2 phần safe code và unsafe code. Safe rust code là những đoạn code sử dụng tính năng thuần được Rust cung cấp, mặc định những đoạn code này sẽ được compiler kiểm tra bằng borrow checker, các luật an toàn khác. Tuy nhiên trong safe rust code không có nghĩa an toàn tuyệt đối, vẫn có những trường hợp phức tạp lập trình viên tạo ra có thể không bị compiler phát hiện, hoặc những chỉ dẫn (markder, annotation) của lập trình viên làm cho compiler bị đánh lừa (vì compiler tin vào chỉ dẫn của người dùng). Phần thứ 2 của Rust là unsafe Rust code. Số lượng dự án viết lại hoàn toàn bằng Rust không nhiều, chủ yếu là các chương trình vốn đã được viết bằng C/C++, do vậy dùng Rust để tương tác với code C/C++, để migrate dần dần dự án C/C++ sang Rust. Để làm được điều này thì Rust cung cấp các chức năng như FFI, WASM Bindgen, ... để có thể gọi được code C/C++ từ Rust. Tuy nhiên khi sử dụng các chức năng này, lập trình viên phải sử dụng unsafe Rust code. Unsafe Rust code là những đoạn code mà compiler không thể kiểm tra được, do vậy lập trình viên phải chịu trách nhiệm kiểm tra an toàn của đoạn code này. Khi không có compiler kiểm tra thì đoạn Rust code sẽ trả về không khác gì C/C++. Dù số lượng unsafe code trung bình trong 1 dự án không nhiều (nhớ cite bài thống kê số liệu), nhưng unsafe code hay thậm chí trong safe code tiềm ẩn rất nhiều rủi ro về bảo mật, do vậy cần có công cụ hỗ trợ phân tích mã nguồn Rust để tìm ra các lỗi tiềm ẩn này.
    \item Rust cung cấp nhiều công cụ hỗ trợ phát triển phần mềm như Cargo, Rustfmt, Clippy, ...
    \item Đã có rất nhiều nghiên cứu, phát triển của các công cụ phân tích mã nguồn, kiểm thử, check vulnerabilities, code smell cho Rust như Rudra, Miri, Yuga, ...
    \item Tuy nhiên các công cụ này đang chỉ sử dụng, phân tích các thuật toán trực tiếp trên mã nguồn (text thuần, sử dụng regex), hoặc là chỉ sử dụng cây cú pháp trừu tượng, hoặc là sử dụng 1 cấu trúc dữ liệu đặc biệt riêng của họ trong quá trình phần tích (Ví dụ Miri sử dụng Stacked Borrow).
    \item Nhấn mạnh thêm nhu cầu kiểm thử của Rust hiện tại là rất lớn. Dù Rust đang trong đà trend trong các năm gần đây, được nhiều dự án lớn adopt nhưng hệ sinh thái (ecosystem) của Rust chưa được lớn mạnh (mature) như các ngôn ngữ C/C++, Java (đã có thâm niên phát triển trong nhiều năm). Hay kể cả đem so sánh với ngôn ngữ Go, cũng là ngôn ngữ trend gần đây (sau Rust) thì ecosystem của Rust vẫn còn quá nhỏ bé. Không chỉ vậy Rust còn muốn được sử dụng cho các chương trình hệ thống, thực hiện các nhiệm vụ khó khăn, nghiêm ngặt hơn như IOT (nhớ cite bài), thậm chí là khám phá vũ trụ (Space) (nhớ cite bài). Do vậy phát triển hệ sinh thái cho Rust nói chung và kiểm thử mã nguồn Rust nói riêng là rất cần thiết (kể cả phân tích tĩnh hay kiểm thử động)
    \item Thứ 1, Khóa luận này đưa ra 1 giải pháp khác cho việc sử dụng cấu trúc dữ liệu thống nhất cho việc phân tích mã nguồn, đó là sử dụng đồ thị thuộc tính mã nguồn (CPG) để biểu diễn mã nguồn Rust.
    \item CPG đã có nhiều nghiên cứu, phát triển cho các ngôn ngữ lập trình khác như Java, C/C++, Python, ... và đã được chứng minh hiệu quả trong việc phân tích mã nguồn.
    \item CPG có rất nhiều implementation khác nhau để phục vụ nhu cầu phân tích mã nguồn khác nhau của các ngôn ngữ
    \item Các công cụ hiện tại như Rudra, Miri chỉ có thể tìm kiếm 1 tập thể loại lỗi nhất định. Ví dụ Rudra chuyên tìm các loại lỗi ... (phải cần tìm hiểu chung chugn về cơ chế thuật toán của Rudra). Tương tự với Miri, Yuga, ...
    \item Kết luận lại là cần 1 nền tảng (cấu trúc dữ liệu) thống nhất để phân tích mã nguồn Rust, cùng 1 cấu trúc dữ liệu nền tảng nhưng có thể áp dụng cho nhiều thể loại lỗi khác nhau (khác phục điểm yếu chỉ áp dụng cho 1 loại lỗi nhất định của các công cụ phía trên) và CPG là 1 giải pháp tốt cho việc này (vì đã được sử dụng cho nhiều ngôn ngữ khác nhau và đã chứng minh hiệu quả).
    \item Thứ 2, gần với Rust nhất thì có CPG cho LLVM-IR. Rust được xây dựng từ LLVM-IR, mã nguồn Rust sẽ được chuyển thành LLVM-IR, do vậy 1 đoạn mã Rust có thể được thay thế bằng 1 đoạn mã LLVM-IR tương ứng. Tuy nhiên đó chỉ là hành vi khi runtime. Thực tế Rust có những tính năng được compiler xây dựng, giúp đảm bảo an toàn khi code (hay compile time) ví dụ như ownership, borrow checker. Có các tính năng hiện tại chỉ có ngôn ngữ Rust có mà ngôn ngữ cùng system level như C/C++ không có. Hay kể cả 1 dạng biểu diễn khác của Rust là LLVM-IR cũng không có. Do vậy xuất hiện nhu cầu phân tích mã nguồn Rust ngay tại tầng source code, chứ không phải ở tần LLVM-IR.
\end{itemize}

Hiện nay, cùng với sự phát triển của công nghệ và độ phủ sóng của internet, ngành công nghiệp phần mềm đang trải qua giai đoạn phát triển mạnh mẽ và đa dạng hóa không ngừng, đi kèm với đó là hàng tỷ người sử dụng.
Các hệ thống phần mềm phải luôn đảm bảo tính sẵn sàng và ổn định bởi vì chỉ một sai xót xảy ra cũng sẽ gây ra những hậu quả khôn lường.
Trong quá trình xây dựng phần mềm, các đội ngũ phát triển phần mềm thường dùng là sử dụng các công cụ phân tích mã nguồn cho việc phát triển, kiểm thử và đảm bảo chất lượng phần mềm.
Các công cụ phân tích mã nguồn sẽ giúp phát hiện các lỗi lập trình, vấn đề về bảo mật hay việc sử dụng tài nguyên kém hiệu quả mà không cần phải thực thi chương trình.
Đồng thời, các công cụ này sẽ giúp cải thiện chất lượng mã nguồn, đảm bảo lập trình viên sẽ tuân thủ các quy tắc và tiêu chuẩn khi viết mã nguồn.
Điều này sẽ giúp giảm thiểu thời gian và công sức cho quá trình kiểm thử và đánh giá mã nguồn.

Hiện tại, trên thị trường đã có nhiều công cụ cung cấp khả năng phân tích mã nguồn như SonarQube, ReSharper hay CodeClimate.
Những công cụ này cung cấp khả năng phân tích mã nguồn cho nhiều ngôn ngữ lập trình khác nhau như C/C++, Java, Javascript, C...
Bên cạnh đó, mỗi ngôn ngữ lập trình lại có thêm nhiều công cụ phân tích mã nguồn khác nhau, nếu xét riêng cho ngôn ngữ lập trình Rust, ta có một số công cụ tiêu biểu như gosec1, staticcheck2 hay govulncheck3.
Đây là các công cụ cung cấp khả năng phân tích cú pháp và tìm lỗ hổng trong mã nguồn.
Điểm chung của các công cụ này là đều sử dụng dạng cây cú pháp trừu tượng được định nghĩa sẵn của Rust nên chúng chỉ dừng lại ở tìm các lỗi dựa trên cú pháp mã nguồn mà không khai thác sâu hơn về luồng điều khiển hay luồng dữ liệu của mã nguồn.
Do vậy, những công cụ này thường cung cấp nhiều cảnh báo giả và bỏ qua nhưng lỗi nghiêm trọng khi phân tích mã nguồn.

Khác với các công cụ vừa nêu, trên thị trường hiện nay còn xuất hiện một công cụ là Joern.
Joern là một nền tảng mã nguồn mở cung cấp khả năng phân tích mã nguồn, mã bytecode và mã nhị phân.
Một công cụ phân tích mã nguồn sẽ gồm ba thành phần chính: phân tích cú pháp mã nguồn (parser), biểu diễn cấu trúc của mã nguồn và phân tích cấu trúc biểu diễn đó [3].
Joern đóng vai trò là một công cụ giúp xử lý hai bước đầu của quá trình phân tích mã nguồn.
Thay vì chỉ sử dụng cây cú pháp trừu tượng, Joern biểu diễn mã nguồn dưới dạng đồ thị thuộc tính mã nguồn và cung cấp chức năng truy vấn khai thác đồ thị này bằng các câu lệnh truy vấn viết bằng ngôn ngữ Scala.
Joern được xây dựng với mục tiêu cung cấp chức năng tìm kiếm lỗ hổng trong mã nguồn và cung cấp các công cụ để xây dựng các trình phân tích tĩnh sử dụng dữ liệu phân tích mà Joern cung cấp.
Điểm đặc biệt của Joern là nó cung cấp dạng đồ thị biểu diễn duy nhất cho tất cả các ngôn ngữ mà nó hỗ trợ (bao gồm C, C++, Java, Javascript, Python...), điều này đem đến khả năng phân tích đa ngôn ngữ, giúp giảm thiểu việc phải xử lý riêng cho từng ngôn ngữ khi chúng ta tìm kiếm lỗi trong mã nguồn hay khi xây dựng các trình phân tích tĩnh dựa trên Joern.

Mặc dù Joern đã cung cấp khả năng phân tích mã nguồn đối với ngôn ngữ Rust tuy nhiên vẫn còn rất hạn chế do chưa xử lý hết toàn bộ các thành phần mã nguồn có trong Rust và thiếu các thông tin về kiểu dữ liệu.
Vì vậy khóa luận này xây dựng một công cụ phân tích mã nguồn dành cho ngôn ngữ lập trình Rust dựa trên mã nguồn của Joern.
Công cụ này sẽ xử lý các thành mã nguồn mà Rust cung cấp một cách chi tiết và đầy đủ hơn, đồng thời cũng xử lý triệt để kiểu dữ liệu để cung cấp đồ thị mã nguồn chi tiết nhất có thể.

Khóa luận sẽ được trình bày theo cấu trúc như sau.
Đầu tiên, Chương 2 thảo luận một số kiến thức cơ sở liên quan đến phân tích mã nguồn, cụ thể cho ngôn ngữ lập trình Rust.
Chương 3 trình bày chi tiết quy trình xây dụng công cụ phân tích.
Tiếp theo, Chương 4 sẽ trình bày kiến trúc, cài đặt công cụ và một số kết quả thực nghiệm đánh giá.
Cuối cùng, tóm tắt những kết quả và kết luận sau quá trình phát triển công cụ sẽ được trình bày ở Chương 5.

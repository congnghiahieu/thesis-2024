\section{Tính áp dụng vào thực tế của đồ thị CPG dành cho Rust}

\subsection{RUSTSEC-2021-0086}

\begin{itemize}
    \item Lỗi access uninitialized memory
\end{itemize}

\begin{listing}[H]
\begin{minted}[mathescape, breaklines, frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{rust}
const N: usize = 255;

// Before fix
let mut buf: Vec<u8> = Vec::with_capacity(N);
unsafe { buf.set_len(N) };

// After fix
let mut buf: Vec<u8> = vec![0; N];
\end{minted}
\caption{Ví dụ mã nguồn cho RUSTSEC-2021-0086}
\label{code:c4_RUSTSEC-2021-0086}
\end{listing}

\subsection{RUSTSEC-2022-0028}

\begin{itemize}
    \item Thể hiện được tính năng bổ sung, rule, pattern của lỗi thể hiển lên CPG
    \item Từ pattern có thể nói rằng có thể sử dụng các luật và học máy để duyệt trên đồ thị CPG, từ đó tìm ra được lỗi
    \item Lỗi không đánh lifetime tường minh cho kiểu T, dẫn đến compiler không thể phát hiện ra lỗi khi compile
\end{itemize}

\begin{listing}[H]
\begin{minted}[mathescape, breaklines, frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{rust}
// Before fix
pub fn external<'a, C, T>(cx: &mut C, data: T) -> Handle<'a, Self>
where
    C: Context<'a>,
    T: AsMut<[u8]> + Send,
{
    // ...
}

// After fix
pub fn external<'a, C, T>(cx: &mut C, data: T) -> Handle<'a, Self>
where
    C: Context<'a>,
    T: AsMut<[u8]> + Send + 'static,
{
    // ...
}
\end{minted}
\caption{Ví dụ mã nguồn cho RUSTSEC-2022-0028}
\label{code:c4_RUSTSEC-2022-0028}
\end{listing}

\subsection{RUSTSEC-2020-0044}

\begin{itemize}
    \item Giải thích Send và Sync trong Rust
    \item Lỗi là do kiểu Atom không đánh Send và Sync cho kiểu P, dẫn đến lỗi khi sử dụng Atom trong multi-thread
    \item Sửa lỗi bằng cách đánh Send và Sync cho kiểu P
    \item Kiểu cha (Wrapper) mà muốn Send được thì kiểu con (P) cũng phải Send được (tương tự với Sync)
    \item Từ đây ta có thể thấy được pattern về lỗi không đánh Send và Sync cho kiểu P rất phổ biến, có thể dùng luật (pattern) traverse trên đồ thị để phát hiện ra lỗi
\end{itemize}

\begin{listing}[H]
\begin{minted}[mathescape, breaklines, frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{rust}
// Before fix
unsafe impl<P> Send for Atom<P> where P: IntoRawPtr + FromRawPtr {}
unsafe impl<P> Sync for Atom<P> where P: IntoRawPtr + FromRawPtr {}

// After fix
unsafe impl<P> Send for Atom<P> where P: IntoRawPtr + FromRawPtr + Send {}
unsafe impl<P> Sync for Atom<P> where P: IntoRawPtr + FromRawPtr + Send {}
\end{minted}
\caption{Ví dụ mã nguồn cho RUSTSEC-2020-0044}
\label{code:c4_RUSTSEC-2020-0044}
\end{listing}

\subsection{RUSTSEC-2021-0130}

\begin{itemize}
    \item Nói về 3 luật lifetime ellision
    \item Lỗi là do self và kiểu Iter không cùng lifetime với nhau. Iter có thể access tới self khi self đã bị drop, dẫn đến lỗi
    \item Sửa lỗi bằng cách sử dụng thống nhất 1 lifetime chung cho self và Iter, sử dụng thông qua bằng quy tắc 3 của lifetime ellision, lifetime của Iter sẽ được auto infer từ lifetime của self
    \item Từ đây ta có thể thấy được pattern về lỗi lifetime không đồng bộ giữa self và kiểu trả về là rất nhiều, có thể dùng luật (pattern) traverse trên đồ thị để phát hiện ra lỗi
\end{itemize}

\begin{listing}[H]
\begin{minted}[mathescape, breaklines, frame=lines, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, linenos]{rust}
// Before fix
pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {
    Iter {
        ptr: unsafe { (*self.head).next },
    }
}

// After fix
pub fn iter(&self) -> Iter<'_, K, V> {
    Iter {
        ptr: unsafe { (*self.head).next },
    }
}
\end{minted}
\caption{Ví dụ mã nguồn cho RUSTSEC-2021-0130   }
\label{code:c4_RUSTSEC-2021-0130}
\end{listing}
\chapter*{Mở đầu}
\setcounter{page}{1}
\pagenumbering{arabic}
Trong thời đại mà những đổi mới về mặt công nghệ đang định hình lại thế giới, nhiều khía cạnh trong cuộc sống hàng ngày của con người đang chuyển dần sang những nền tảng ảo. Mô hình của các nền tảng này hướng đến khả năng kết nối và trao đổi thông tin giữa nhiều thiết bị công nghệ giúp tối ưu hóa sự tiện nghi cho con người, tuy nhiên từ đó lại đi kèm rủi ro khi dữ liệu riêng tư của người dùng được chia sẻ qua không gian mạng. Các cuộc tấn công khai thác lỗ hổng phần mềm (Software Vulnerability) nhằm vào hệ thống phần mềm máy tính, đặc biệt là các hệ thống quan trọng như quản lý dữ liệu công dân quốc gia, giao thông, điều phối hàng không, vận hành công nghiệp hóa học/hạt nhân, và các hệ thống an ninh quốc phòng, và có thể gây ra thiệt hại đáng kể. Theo khảo sát của Veracode trên hơn 130,000 phần mềm năm 2020, hơn 75\% trong số đó chứa ít nhất một lỗ hổng phần mềm~\cite{veracode}. Các lỗ hổng phổ biến bao gồm: kiểm soát truy cập bị hỏng (Broken Access Control), lỗi mật mã (Cryptographic Failures), SQL Injections, thiết kế không an toàn, cấu hình bảo mật sai. Vào năm 2021, 97\% phần mềm trong tổng số 2,409 phần mềm có chứa mã nguồn mở~\cite{synopsys}. 80\% trong số đó có chứa ít nhất một lỗ hổng phần mềm. 


Từ đó, một trong những mục tiêu quan trọng nhất của công nghệ phần mềm là làm thế nào để xây dựng phần mềm có khả năng đứng vững trước sự tấn công vào những lỗ hổng có trong phần mềm~\cite{mcgraw2006software}. Hiện nay có rất nhiều giải pháp được thiết kế nhằm giúp các nhà phát triển phần mềm xây dựng phần mềm an toàn hơn, chẳng hạn như thiết kế phần mềm theo quy chuẩn chung, kiểm thử phần mềm, nhận diện và phân tích các lỗ hổng để đánh giá tác động của những chúng lên phần mềm, và giảm độ phức tạp và tăng khả năng mở rộng của phần mềm, v.v. Ngoài ra, việc thực thi các phương pháp phân tích chương trình khác nhau trên mã nguồn phần mềm hoặc trên các phiên bản đã biên dịch có thể giúp phát hiện ra các lỗ hổng bảo mật tiềm ẩn có thể xảy ra. Nhìn chung, các phương pháp tiếp cận phân tích mã có thể được chia thành hai nhóm chính: Phân tích mã nguồn tĩnh (Static Code Analysis - SCA) và Phân tích chương trình động (Dynamic Program Analysis - DPA)~\cite{mcgraw2006software}.

Những nghiên cứu trước đây đã cho thấy DPA là một kỹ thuật hiệu quả để tìm ra các lỗi bảo mật tiềm ẩn trong mã nguồn bằng cách phân tích các hành vi của chương trình khi nó đang thực thi~\cite{andreasen2017survey}. Hơn nữa, kỹ thuật DPA có thể yêu cầu can thiệp và sửa đổi mã nguồn chương trình nhằm mục đích thu thập dấu vết trong quá trình chạy để phát hiện được những hành vi nghi vấn~\cite{larus1994rewriting}. Tuy nhiên, nhược điểm của DPA là phải chịu chi phí về mặt thời gian khi phải thực thi chương trình phức tạp. Bên cạnh đó, việc dựa vào DPA để tìm các lỗi có trong mã nguồn phần mềm có thể không còn hữu dụng khi thời điểm lỗi được phát hiện thường nằm về cuối của vòng đời phát triển phần mềm. Trái ngược với DPA, SCA xác định các lỗi tiềm ẩn trong phần mềm bằng cách phân tích mã nguồn hoặc mã nhị phân của phần mềm mà không cần thực thi~\cite{zheng2006value}. Các cảnh báo về lỗi phần mềm do các công cụ SCA tạo ra có thể được phân loại thành 3 nhóm chính: (1) \textit{dương tính giả} (False Positive - FP): là cảnh báo về lỗi nhưng thực sự thì lỗi đó không tồn tại; (2) \textit{dương tính thật} (True Positive - TP): là cảnh báo đúng về các lỗi tiềm ẩn đang nằm trong mã nguồn; (3) {âm tính giả} (False Negative - FN): là khi SCA không phát hiện ra lỗi, mặc dù thực sự lỗi có tồn tại trong mã nguồn~\cite{alikhashashneh2018using}.

Trong quá khứ đã có một số nghiên cứu tập để đánh giá chất lượng của các công cụ phân tích tĩnh (SCA Tool). Nghiên cứu của Ramos~\cite{ramos2016evaluating} đã đánh giá độ chính xác của Visual Code Grepper, FindBugs và SonarQube trong việc phát hiện các lỗ hổng SQL Injections, OS Command và LDAP Injections đối với bộ dữ liệu chuẩn Java Juliet~\cite{JULIET}. Tương tự như vậy, McLean~\cite{mclean2012comparing} đã thực hiện đánh giá một số công cụ phân tích tĩnh đối với các ứng dụng mã nguồn mở được sử dụng rộng rãi, chẳng hạn như Apache OpenOffice (AOO)~\cite{steinberg2013apache}, PuTTY~\cite{dooley2006cisco}, NMAP~\cite{lyon2008nmap} và Wireshark~\cite{orebaugh2006wireshark}. Tuy nhiên, giống như nhiều công cụ và kỹ thuật khác, công cụ phân tích tĩnh có một số nhược điểm cố hữu, trong đó nổi bật là việc SCA thường tạo ra một số lượng lớn các kết quả dương tính giả và âm tính giả. Trên thực tế, Kremenek và Engler~\cite{kremenek2003z} đã quan sát thấy rằng tỷ lệ dương tính giả đối với một số công cụ SCA nằm trong khoảng từ 30\%-100\%. Các nghiên cứu khác~\cite{boogerd2006prioritizing,heckman2008establishing} cũng đã chỉ ra rằng 35\%-91\% cảnh báo được báo cáo là dương tính giả. Theo nguyên tắc, để tránh bỏ sót lỗi có trong phần mềm thì các lập trình viên vẫn phải kiểm tra thủ công tất cả các cảnh báo đã được tạo ra để xác định chúng là cảnh báo dương tính giả hay dương tính thật. Tuy nhiên việc kiểm tra tất cả cảnh báo theo cách thủ công tiêu tốn một lượng lớn thời gian và nguồn lực, từ đó trở thành rào cản chính khiến các nhà phát triển phần mềm ngần ngại sử dụng các công cụ SCA cho các dự án của họ. Một giải pháp để giải quyết vấn đề này là thiết kế bước hậu xử lý giúp loại bỏ các cảnh báo dương tính giả một cách tự động, từ đó giữ lại được những cảnh báo có khả năng cao là dương tính thật để được đưa vào kiểm tra thủ công.

Theo định hướng đó, để giải quyết vấn đề về cảnh báo sai của các công cụ phân tích tĩnh, luận văn này sẽ trình bày một giải pháp giúp xếp hạng lại tập cảnh báo được tạo ra bởi các công cụ phân tích tĩnh. Ý tưởng chính của nghiên cứu dựa trên quan sát rằng các cảnh báo có bối cảnh tương tự thường có nhãn tương tự (TP hoặc FP). Đối với mỗi cảnh báo, giải pháp sẽ phân tích ngữ cảnh của cảnh báo cả về mặt cú pháp và ngữ nghĩa, sau đó áp dụng mô hình học sâu để dự đoán khả năng cảnh báo đó là TP (hay FP). Cụ thể, để có được ngữ cảnh của một cảnh báo, \tool áp dụng các kĩ thuật phân tích chương trình để trích xuất tất cả các câu lệnh có ảnh hưởng và bị ảnh hưởng bởi câu lệnh bị đánh dấu bởi công cụ phân tích tĩnh. Sau đó, để thể hiện giúp mô hình học được những mẫu ngữ cảnh chung, tên của các hằng số/biến số/phương thức sẽ được thay thế bằng tên trừu tượng. Tiếp theo, các câu lệnh bị cảnh báo và ngữ cảnh liên quan sẽ được véc-tơ hóa và dùng làm đầu vào để huấn luyện các mô hình mạng học sâu. Cuối cùng, các cảnh báo đầu vào sẽ được xếp hạng theo điểm dự đoán tương ứng của mô hình học sâu.

Ngoài ra, theo hiểu biết của học viên, hiện tại vẫn chưa có một bộ dữ liệu công khai nào được xây dựng trên các hệ thống phần mềm thực tế để đánh giá độ hiệu quả của các phương pháp hậu xử lý cảnh báo sai sinh ra từ các công cụ phân tích tĩnh. Trong các nghiên cứu hiện có~\cite{flynn2018prioritizing, berman2019active}, các mô hình học máy thường được đào tạo và thử nghiệm trên các bộ dữ liệu tổng hợp là Juliet~\cite{JULIET} và SARD~\cite{SARD}. Tuy nhiên, các bộ dữ liệu này đều chỉ bao gồm các ví dụ đơn giản với các lỗi được tạo ra dựa trên các mẫu lỗ hổng đã biết. Nghiên cứu của Chakraborty và cộng sự~\cite{chakraborty2021deep} cũng đã chứng minh rằng các bộ dữ liệu còn quá đơn giản và không phản ánh được hiệu suất của các cách tiếp cận khi được áp dụng trong thực tế. Vì vậy, để giải quyết hạn chế thiếu hụt dữ liệu, luận văn này còn đóng góp một bộ dữ liệu chứa 6,620 cảnh báo của 10 dự án phần mềm mã nguồn mở.

Về kết quả thực nghiệm, giải pháp \tool cho thấy rằng khoảng 60\% lỗ hổng thực tế được \tool xếp hạng sẽ nằm trong 20\% cảnh báo đầu tiên của danh sách. Hơn nữa, lập trình viên sử dụng \tool có thể tìm thấy hơn 90\% lỗ hổng thực tế mà chỉ cần kiểm tra 60\% tổng số cảnh báo. Trong khi đó, bằng cách sử dụng phương pháp được cho là tốt nhất hiện nay~\cite{lee2019classifying}, các lập trình viên chỉ có thể tìm thấy 46\% và 82\% số lượng cảnh báo là TP với cùng số lượng cảnh báo được kiểm tra.

Về chi tiết, luận văn sẽ được trình bày theo cấu trúc như sau. Chương 1 sẽ giới thiệu kĩ hơn về những vấn đề mà các công cụ phân tích tĩnh đang gặp phải, những nghiên cứu trước đây và đặt vấn đề cần giải quyết trong luận văn này. Chương 2 sẽ nhắc lại sơ lược một số kiến thức cơ sở về công cụ phân tích tĩnh, các kĩ thuật phân tích chương trình và mô hình học biểu diễn bằng học sâu. Giải pháp được xây dựng trong luận văn sẽ được mô tả chi tiết ở Chương 3. Tiếp theo, Chương 4 tập trung vào việc thử nghiệm phương pháp và đánh giá kết quả chi tiết. Phần cuối cùng rút ra kết luận và hướng mở rộng trong tương lai.

\cleardoublepage
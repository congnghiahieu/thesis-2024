\section{Hạn chế}

\subsection{Macro}

\begin{itemize}
    \item Marco (nhớ cite định nghĩa macro là gì) của Rust không được giải ở bước sinh cây AST mà sẽ được giải sau khi sinh cây AST nhưng trước khi đi vào phase Semantic Ananlysis (nhớ cite Semantinc Analysis)
    \item Rust không giống C/C++. C/C++ có preprossor để giải Marco trước khi cho vào compiler, đo đó khi mã nguồn sau khi được tiền xử lý thì đã được giải toàn bộ Macro
    \item Mà thư viên $syn$ chỉ là thư viện hỗ trợ sinh cây AST, không hỗ trợ giải Macro. Do đó tất cả các mã lệnh nằm bên trong macro sẽ không được giải, dẫn đến việc không thể sinh cây AST cho macro. Tất cả các đoạn lệnh nằm trong 1 lời gọi macro hiện tại được xem như 1 chuỗi token, không thể phân biệt được các token trong đó.
    \item Không chỉ vậy macro trong Rust sử dụng DSL riêng, DSL gần với ngôn ngữ Rust nhưng có sử mở rộng biến đổi để phù hợp với vai trò là 1 macro (inline function), do đó không thể sinh cây AST cho macro.
    \item Có 1 ý tưởng để giải trường hợp này là tự tạo 1 bước toàn xử lý mã nguồn để giải macro như C/C++. Chúng ta sẽ sử dụng đến thư viện $cargo-expand$, thư viện này có tác dụng đưa đoạn code Rust mà lập trình viên nhìn thấy (dạng đã được rút gọn đi) thành đoạn code Rust mà compiler nhìn thấy (trước khi cho vào compiler). Đoạn code sau khi được mở rộng thì sẽ có được các thông tin bị ẩn đi như prelude mặc định của Rust (các hàm, symbol được built-in trong ngôn ngữ mà người dùng không phải import thủ công), các macro sẽ được giải, bao gồm declarative và procedural macro. Đối với declarative macro, thì macro được built-in của ngôn ngữ như $println!$, $vec!$ hay kể cả declarative macro do người dùng định nghĩa cũng sẽ được giải.
    \item Tuy nhiên, việc giải macro trước khi cho vào cây AST sẽ làm cho mã nguồn bị biến đổi (không còn là những gì mà lập trình viên nhìn thấy), tăng kích cỡ và độ lớn của mã nguồn. Việc thêm các thông tin ẩn mà lập trình viên không nhìn thấy có thể gây nhầm lẫn cho người đọc mã nguồn, cũng như làm tăng độ phức tạp của mã nguồn. Điều này cũng đồng nghĩa với việc việc sinh cây AST cho mã nguồn sau khi giải macro sẽ phức tạp hơn, việc này sẽ làm tăng thời gian xử lý mã nguồn, cũng như làm tăng độ phức tạp của mã nguồn.
    \item Xem thêm \href{https://veykril.github.io/tlborm/syntax-extensions/source-analysis.html}{The Little Book of Rust Macros}
    \item \href{https://arxiv.org/pdf/2211.05627}{Representing LLVM-IR in a Code Property Graph}
\end{itemize}

\subsection{Module}

\begin{itemize}
    \item Giải thích module trong Rust là gì (nhớ cite định nghĩa module trong Rust), gồm keyword mod, pub, use
    \item Module có thể được định nghĩa trong 1 file, nhưng mỗi 1 file có thể là 1 module. Module muốn sử dụng module khác thì phải sử dụng keyword use. Về cơ bản đây là mối quan hệ phức tạp, nếu chỉ có 1 module thì sử dụng 1 symbol table, nhưng nhiều module, import trait, struct từ module khác rất phức tạp nên hiện tại chưa làm được.
    \item Hệ thống module trong Rust giúp tổ chức và quản lý mã nguồn một cách hiệu quả. Dưới đây là các thành phần chính và cách hoạt động của hệ thống module và import trong Rust:

    Thành phần của hệ thống module
    Module (mod): Module là đơn vị tổ chức mã nguồn trong Rust. Một module có thể chứa các hàm, cấu trúc dữ liệu, hằng số, và các module con khác. Module được khai báo bằng từ khóa mod.

    Crate: Crate là đơn vị biên dịch và phân phối mã nguồn trong Rust. Một crate có thể là một thư viện hoặc một ứng dụng. Mỗi crate có thể chứa nhiều module.

    Path: Đường dẫn (path) được sử dụng để truy cập các thành phần trong module. Có hai loại đường dẫn:

    Absolute Path: Đường dẫn tuyệt đối bắt đầu từ crate root.
    Relative Path: Đường dẫn tương đối bắt đầu từ module hiện tại.
    Visibility: Mặc định, các thành phần trong module là private. Để làm cho chúng public, sử dụng từ khóa pub.
    \item Xem thêm \href{https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html}{Managing Growing Projects with Packages, Crates, and Modules}
\end{itemize}

\subsection{Path}

\begin{itemize}
    \item Path có thể là Absolute Path hoặc Relative Path tùy vào bối cảnh module hiện tại, path có thể chỉ tới đối tượng trong cùng 1 module hoặc khác module
    \item Path trong Rust là đường dẫn đến 1 đối tượng nào đó được định nghĩa trong mã nguồn như struct, trait, static, const, function
    \item Cây AST sử dụng thư viện $syn$, $syn$ có thể lấy được path của 1 đối tượng nhưng không biết được đối đượng đang trỏ tới là static, const, hay function. Do đó đang không phân biệt được đâu là path của static, const, hay function
\end{itemize}

\subsection{Type Argument match Type Parameter}

\chapter{Phương pháp }


Phương pháp đánh giá điểm thưởng được trình bày trong chương này tập trung vào việc tác động đến mức độ phủ của bài toán kiểm thử API, đồng thời đảm bảo tính hiệu quả và toàn diện trong quá trình đánh giá. Để đạt được mục tiêu này, phương pháp đề xuất xét đến nhiều khía cạnh quan trọng khác nhau của API và quá trình kiểm thử. Bên cạnh đó, chương này cũng trình bày về việc mở rộng và tinh chỉnh nguồn sinh dữ liệu mới cho công cụ, dựa trên việc khai thác thông tin thu thập trong quá trình kiểm thử.



\section{Hướng tiếp cận}
\subsection{Phương pháp đánh giá điểm thưởng trong bài toán kiểm thử API sử dụng học tăng cường}




Hiện tại, ARAT-RL đánh giá điểm thưởng cho các hành động dựa trên mã trạng thái trả về. Tuy nhiên, phương pháp này bộc lộ một số điểm yếu, bao gồm khả năng xử lý thông tin trả về hạn chế và hiệu quả tìm lỗi chưa tối ưu. Thứ nhất, phương pháp này không xử lý tốt các thông tin trả về ngoài mã trạng thái, dẫn đến việc bỏ sót những dữ liệu quan trọng có thể ảnh hưởng đến việc đánh giá điểm thưởng. Thứ hai, việc chỉ tập trung khai thác mã trạng thái trả về khiến quá trình tìm lỗi chưa hiệu quả, bỏ sót nhiều lỗi tiềm ẩn gây ra bởi các thành phần khác.

Báo cáo này trình bày phương pháp đánh giá nhằm khắc phục những điểm yếu nêu trên. Phương pháp này hướng đến hai mục tiêu chính: ưu tiên định hướng sinh các ca kiểm thử vào vùng có lỗi (những yêu cầu trả về mã trạng thái \texttt{5xx}) và đa dạng hóa phản hồi để tối ưu hóa độ phủ đầu ra. Nhờ đó, về lâu dài, công cụ có khả năng phát hiện lỗi hiệu quả hơn. Để đạt được hai mục tiêu này, phương pháp đánh giá áp dụng đồng thời hai chiến lược chính.

\textbf{Chiến lược đầu tiên} tập trung vào việc ưu tiên định hướng sinh các ca kiểm thử vào vùng có lỗi. Cụ thể, điều này bao gồm việc phân loại các mã trạng thái trả về từ các yêu cầu API, từ đó ưu tiên kiểm thử các thao tác trả về mã trạng thái \texttt{5xx}, tức là những yêu cầu có lỗi xảy ra. Bằng cách tập trung vào các mã trạng thái này, chúng ta có thể nhanh chóng xác định và xử lý các vấn đề nghiêm trọng nhất trong hệ thống.

Ngoài ra, việc xem xét các yêu cầu có mã trả về nằm ngoài đặc tả API cũng rất quan trọng. Các yêu cầu này có thể chỉ ra những lỗi tiềm ẩn không được dự đoán trước, góp phần tăng cường độ phủ kiểm thử và khả năng phát hiện lỗi. Điều này bao gồm cả những mã trạng thái bất thường hoặc không mong đợi, giúp đảm bảo rằng hệ thống hoạt động đúng theo đặc tả trong mọi tình huống.

Việc kết hợp phân loại mã trạng thái và xem xét các yêu cầu nằm ngoài đặc tả API sẽ định hướng việc lựa chọn các nguồn sinh dữ liệu đầu vào một cách hiệu quả. Bằng cách này, chúng ta có thể tối ưu hóa khả năng phát hiện lỗi của công cụ kiểm thử, đảm bảo rằng các nguồn dữ liệu được chọn có khả năng cao phát hiện các vấn đề trong hệ thống. Nhờ đó, quá trình kiểm thử trở nên hiệu quả hơn, giúp phát hiện và sửa chữa lỗi một cách nhanh chóng và chính xác.



\textbf{Chiến lược thứ hai} tập trung vào việc đa dạng hóa phản hồi để tối ưu hóa độ phủ đầu ra. Phương pháp này khuyến khích việc tìm kiếm và phát hiện các lỗi mới thay vì chỉ tập trung vào việc tái tạo những lỗi đã được ghi nhận trước đây. Cách tiếp cận này nhắm đến việc tạo ra các ca kiểm thử mới có khả năng cao phát hiện ra các lỗi tiềm ẩn chưa được nhận diện trước đó. Bằng cách này, chúng ta có thể mở rộng phạm vi kiểm thử và đảm bảo rằng hệ thống được kiểm tra một cách toàn diện và kỹ lưỡng.

Một phần quan trọng của chiến lược này là việc đánh giá, so sánh với danh sách các ca kiểm thử đã được thực hiện trước đó. Thông qua việc phân tích này, giải pháp nhằm phát triển các ca kiểm thử mới và đa dạng hơn, tránh việc lặp lại các ca kiểm thử tương tự, vốn có thể dẫn đến sự trùng lặp và lãng phí tài nguyên. Đồng thời, việc khuyến khích sự đa dạng của các ca kiểm thử không chỉ giúp phát hiện ra các lỗi mới mà còn đảm bảo rằng API được kiểm thử dưới nhiều điều kiện và kịch bản khác nhau. Điều này làm tăng khả năng phát hiện ra các lỗi mà chỉ xuất hiện trong những tình huống đặc biệt hoặc ít phổ biến. Từ đó, công cụ kiểm thử có thể đảm bảo rằng hệ thống hoạt động đúng và ổn định trong mọi tình huống, từ đó cải thiện chất lượng và độ tin cậy của API.






\subsection{Mở rộng nguồn sinh dữ liệu cho công cụ ARAT-RL}
Hiện tại, ARAT-RL hỗ trợ 5 nguồn sinh dữ liệu đầu vào với 5 chiến thuật khác nhau: giá trị ví dụ trong tài liệu, giá trị được xây dựng dựa trên phản hồi trước đó, giá trị được xây dựng dựa trên yêu cầu trước đó, giá trị mặc định, giá trị ngẫu nhiên dựa trên các ràng buộc của tài liệu. Mỗi chiến thuật này đều có đặc điểm riêng biệt và phục vụ cho các mục đích khác nhau trong quá trình sinh dữ liệu.

Qua tìm hiểu mã nguồn, tôi nhận thấy công cụ hỗ trợ mở rộng các nguồn sinh mã nguồn theo chiều ngang, nâng cao tính đa dạng của dữ liệu đầu vào. Điều này mang lại lợi ích to lớn, giúp ARAT-RL có thể thích ứng với nhiều trường hợp sử dụng khác nhau hơn. Việc mở rộng các nguồn sinh dữ liệu không chỉ làm phong phú thêm các loại dữ liệu đầu vào mà còn cải thiện khả năng của hệ thống trong việc xử lý các tình huống phức tạp và đa dạng.

Bên cạnh đó, đối với nguồn sinh dữ liệu ngẫu nhiên, hiện tại ARAT-RL đang sử dụng hàm sinh ngẫu nhiên mặc định của Python. Tuy nhiên, hàm sinh ngẫu nhiên mặc định này có thể không đáp ứng được tất cả các yêu cầu về độ chính xác và hiệu quả. Việc sử dụng các thư viện sinh ngẫu nhiên bên thứ ba có thể mang lại nhiều lợi ích. Các thư viện này cung cấp các thuật toán sinh ngẫu nhiên phức tạp và đa dạng hơn, giúp cải thiện hiệu quả và độ chính xác của việc tạo dữ liệu ngẫu nhiên. Sử dụng các thư viện bên thứ ba cũng có thể giúp tối ưu hóa hiệu suất hệ thống và giảm thời gian xử lý, đặc biệt là khi làm việc với các bộ dữ liệu lớn và phức tạp.



\section{Thiết kế giải pháp}
\subsection{Phương pháp đánh giá điểm thưởng trong bài toán kiểm thử API sử dụng học tăng cường}

% \begin{figure}[H]
% 	\includegraphics[width=1\columnwidth]{figures/c3/ppdanhgia.drawio (1).png}
% 	\centering
% 	\caption{Tổng quan về phương pháp đánh giá}
% 	\label{img:rewarding_workflow}
% \end{figure}

Hình \ref{img:rewarding_workflow}  trình bày tổng quan về giải pháp đánh giá điểm thưởng. Đầu vào của quá trình này là thông tin về phản hồi nhận từ hệ thống, là kết quả của một yêu cầu. Trong đó, mã trạng thái của phản hồi cho biết hoạt động đó thành công hay không. Mỗi mã trạng thái phản hồi có ý nghĩa riêng, được phân loại thành 4 nhóm, mỗi nhóm có ý nghĩa riêng và đóng góp khác nhau vào quá trình kiểm thử:
\begin{itemize}
    \item \textbf{Không phản hồi (No response):} Đây là trường hợp không mong muốn của một lời gọi API. Việc không nhận được phản hồi có nghĩa là không có thông tin để xác định liệu SUT (hệ thống đang được kiểm thử) đang chạy chính xác hay gặp vấn đề với môi trường mạng.

\item  \textbf{401 (Chưa được chứng thực) và 403 (Không được phép truy cập):} Các mã trạng thái HTTP 401 (Chưa được chứng thực) và 403 (Không được phép truy cập) chỉ ra các vấn đề liên quan đến quyền truy cập của người dùng đối với các tài nguyên API. Khi gặp phải các mã trạng thái này trong quá trình kiểm thử, ta cần phải lưu ý một số điểm. Những điểm này sẽ giúp hiểu rõ hơn về nguyên nhân và cách xử lý tình huống.

Mã trạng thái 401 (Chưa được chứng thực) được trả về khi người dùng hoặc hệ thống gửi yêu cầu tới máy chủ mà không kèm theo thông tin xác thực hợp lệ. Điều này có nghĩa là máy chủ yêu cầu người dùng cung cấp thông tin xác thực (như tên đăng nhập và mật khẩu) nhưng thông tin này hoặc không được cung cấp hoặc không chính xác. Khi nhận mã 401, máy chủ không thực hiện bất kỳ hành động nào đối với tài nguyên yêu cầu vì không có thông tin xác thực. Do đó, mã trạng thái này không có giá trị trong quá trình kiểm thử tính năng của SUT (System Under Test) vì không thể tiến hành bất kỳ kiểm tra nào liên quan đến hành động cụ thể trên tài nguyên API.

Mã trạng thái 403 (Không được phép truy cập) được trả về khi người dùng hoặc hệ thống đã xác thực thành công nhưng không có quyền truy cập vào tài nguyên được yêu cầu. Điều này xảy ra khi người dùng không có quyền hoặc vai trò cần thiết để thực hiện hành động mong muốn trên tài nguyên đó. Khi nhận mã 403, máy chủ từ chối thực hiện hành động yêu cầu vì vấn đề quyền truy cập. Điều này cũng có nghĩa là không có bất kỳ thay đổi nào xảy ra trên tài nguyên API và không có thông tin hữu ích nào để khai thác cho mục đích kiểm thử.

Tóm lại, cả hai mã trạng thái này đều liên quan đến vấn đề quyền truy cập và không cung cấp thông tin hữu ích cho quá trình kiểm thử tính năng của SUT. Chúng chỉ ra rằng vấn đề không nằm ở SUT mà ở việc cấp quyền truy cập. Vì vậy, khi gặp phải các mã này trong quá trình kiểm thử, cần kiểm tra lại thông tin xác thực và quyền truy cập của người dùng trước khi tiếp tục kiểm tra các tính năng của hệ thống.

\item  \textbf{Các nhóm 4xx, 3xx và 2xx: }Các nhóm này thể hiện những trạng thái của SUT. Cụ thể, nhóm \texttt{2xx} và \texttt{3xx} biểu thị yêu cầu đã được thực hiện thành công. Ngược lại, nhóm \texttt{4xx} biểu thị yêu cầu thực hiện thất bại, xuất hiện lỗi từ phía máy khách. Mặc dù các nhóm mã trạng thái này không trực tiếp giúp tìm kiếm lỗi bên phía máy chủ nhưng chúng cũng giúp ta mở rộng tập các mã trạng thái được kiểm thử, tăng độ phủ đầu ra.

\item \textbf{Nhóm 5xx: }Mã trạng thái \texttt{500} cho biết có một số lỗi trạng thái nội bộ của SUT trong khi xử lý đầu vào yêu cầu tương ứng. Đây là kết quả không mong muốn nhất từ một lời gọi API, nhưng mặt khác lại là phản hồi có giá trị nhất trong kiểm thử API.
\end{itemize}

Dựa trên hướng tiếp cận cốt lõi, giải pháp thiết kế cơ chế điểm thưởng hoạt động theo hai vòng riêng biệt. Mỗi vòng đánh giá bốn nhóm mã trạng thái được đề cập ở trên từ các góc độ khác nhau. Vòng một nhằm mục đích đánh giá điểm thưởng phù hợp dựa trên mã trạng thái trả về, đánh giá khả năng phát hiện lỗi của lời gọi API vừa được thực hiện. Điều này phù hợp với mục tiêu "Ưu tiên định hướng sinh các ca kiểm thử vào vùng có lỗi". Vòng thứ hai tính toán điểm thưởng dựa trên tính mới của phản hồi. Chi tiết của từng vòng được trình bày bên dưới.\\

\noindent\textbf{Vòng 1: Đánh giá điểm thưởng Dựa trên Mã Trạng thái }

Ở vòng 1, điểm thưởng sẽ được đánh giá dựa trên mã trạng thái trả vè, đánh giá dựa trên khả năng phát hiện lỗi của yêu cầu vừa được thực hiện. Dựa trên 4 nhóm mã trạng thái đã được phân loại, phương pháp sẽ sẽ đưa ra điểm thưởng phù hợp dựa trên các lý luận sau đây:
\begin{itemize}
    \item \textbf{Không phản hồi: }Sự thiếu phản hồi có thể đến từ một số yếu tố: thứ nhất, máy chủ quá tải dẫn đến hết thời gian chờ; thứ hai, xử lý mã nguồn chậm dẫn đến hết thời gian chờ; và thứ ba, sự hiện diện của lỗi khiến việc trả về phản hồi bị chặn. Đối với lý do thứ nhất, công cụ nên tránh tiếp tục kiểm tra điểm truy cập đó, vì vậy điểm thưởng sẽ mang tính tiêu cực. Tuy nhiên, tình trạng quá tải có thể chỉ là tạm thời, do đó có thể cho phép kiểm thử lại ở giai đoạn sau của quá trình kiểm thử. Mặc dù điểm thưởng trong trường hợp này mang tính tiêu cực, nhưng chúng không nghiêm trọng bằng trường hợp lỗi 401 và 403. Đối với lý do thứ hai và thứ ba, đây là những trường hợp lỗi. Dù mang lại giá trị cho mục đích kiểm thử, nhưng việc thiếu phản hồi sẽ không mang lại giá trị về mặt khai thác thêm thông tin và mô hình không thể tiếp nhận kiến thức từ các yêu cầu này. Giải pháp chung cho các trường hợp không có phản hồi là tránh tiếp tục kiểm tra điểm truy cập đó.
    \item \textbf{401 (Không được xác thực), 403 (Không được ủy quyền):} Các điểm truy cập (endpoint) không được xác thực thường trả về mã 401 hoặc 403. Nếu không thể gửi yêu cầu đến điểm truy cập do xác thực, thì điểm truy cập đó sẽ không bao giờ nên được kiểm tra trong quá trình kiểm thử. Chúng ta nên tránh kiểm tra thêm và không kiểm tra lại bằng việc giảm đáng kể điểm thưởng.
    \item  \textbf{Các nhóm 4xx, 3xx và 2xx:} Như đã đề cập ở trên, các nhóm này giúp tăng độ phủ đầu ra. Tuy nhiên, những phát hiện này không đóng góp đáng kể vào việc phát hiện lỗi. Do đó, với các nhóm \texttt{2xx} và \texttt{3xx}, điểm thưởng cho các trường hợp này vẫn mang tính tích cực, nhưng ở mức độ vừa phải. Tương tự, với nhóm \texttt{4xx}, điểm thưởng mang tính tiêu cực, nhưng cũng ở mức độ vừa phải. Dù vậy, nếu mã trạng thái trả về không được định nghĩa trong đặc tả API, điểm thưởng sẽ được điều chỉnh tăng thêm để khuyến khích việc phủ những mã trạng thái mới. Việc phát hiện mã trạng thái ngoài đặc tả cũng được coi là khám phá mới nhưng nó không được coi là quan trọng, do đó chỉ nhận được điểm thưởng vừa phải.
    \item \textbf{Nhóm 5xx:} Trong kiểm thử API, nhóm mã trạng thái này luôn là mục tiêu chính của kiểm thử API và điểm thưởng của chúng sẽ theo hướng tích cực. Đặc biệt, trong nhóm này, lỗi \texttt{500} có ý nghĩa quan trọng. Lỗi \texttt{500}, hay "Internal Server Error" thường chỉ ra rằng có sự cố bên trong máy chủ, gây ra bởi một lỗi trong mã nguồn, lỗi cấu hình, hoặc một tình huống không lường trước được trong quá trình xử lý yêu cầu. Vậy nên, việc phát hiện và xác định lỗi \texttt{500}
 được ưu tiên hơn cả, mang ý nghĩa là tìm thấy lỗi trực tiếp của hệ thống. Điều này cực kỳ có giá trị trong quá trình kiểm thử vì nó giúp phát hiện ra các lỗ hổng và vấn đề tiềm ẩn mà hệ thống cần khắc phục.
\end{itemize}
  \noindent\textbf{Vòng 2: Đánh giá Thưởng Dựa trên Tính Mới của Phản Hồi }


Ở vòng 2, điểm thưởng được đánh giá dựa trên mức độ mới của phản hồi. Một phản hồi được coi là mới khi  xuất hiện ít thường xuyên hoặc chưa từng xuất hiện trước đây, với mục tiêu là tăng phạm vi kiểm thử.
Ngược lại, một phản hồi được coi là quen thuộc khi nó được trả về thường xuyên. Ngay cả với một phản hồi mang mã trạng thái \texttt{5xx}, nó không mang lại nhiều ý nghĩa nếu xuất hiện quá nhiều lần. Việc kiểm tra tính mới cũ của phản hồi giúp tránh tạo ra các yêu cầu tương tự lặp đi lặp lại, từ đó tăng được hiệu quả trong việc kiểm thử.

Khi cài đặt thuật toán, điểm thưởng đạt được ở vòng 1 sẽ đóng vai trò là đầu vào cho vòng 2. Ở vòng 2, một hệ số, được ký hiệu là $d$, được sử dụng để làm tham chiếu đánh giá tính mới của phản hồi. Điều này được thực hiện bằng cách nhân điểm thu được ở vòng 1 với hệ số $d$  (phương trình \ref{eq:reward}).


\begin{equation}
\label{eq:reward}
    reward_{r2} = reward_{r1} \times d
\end{equation}

Giải pháp tổng quát cho vòng 2 là so sánh phản hồi hiện tại với $k$ phản hồi gần nhất trong lịch sử trên cùng một hoạt động (operation) và cùng một mã trạng thái để đánh giá tính mới của phản hồi hiện tại. Phương pháp này xác định số lượng phản hồi trước đây tương đồng với phản hồi hiện tại bằng cách so sánh với $k$ phản hồi gần nhất. Hệ số $d$ có xu hướng giảm dần nếu số lượng phản hồi tương đồng tăng lên và ngược lại.
Giá trị cụ thể hệ số $d$ cũng phụ thuộc vào từng loại nhóm mã trạng thái đã trình bày ở vòng 1. Mục đích chung của vòng này là  tránh lặp lại cùng một phản hồi một cách thường xuyên.

% Trường hợp thứ nhất là khi không có phản hồi hoặc phản hồi trả về mã \texttt{401} (Chưa được xác thực) hoặc \texttt{403} (Không được ủy quyền). Trong tình huống này, để tránh kiểm thử thêm các điểm truy cập không có phản hồi, chúng ta không cần kiểm tra $k$ phản hồi gần nhất và phần thưởng vẫn giữ ở mức như trong vòng 1, với hệ số $d$ không đổi ở mức 1.

% Trường hợp thứ hai bao gồm các mã trạng thái nhóm \texttt{5xx}, \texttt{4xx}, \texttt{3xx} và \texttt{2xx}. Khi phản hồi trả về một trong các mã trạng thái này, nó cho thấy một số chức năng của SUT đã được thực thi và đầu ra đã được tạo, do đó, điểm thưởng sẽ có xu hướng tích cực. Đặc biệt, mã trạng thái 5xx là mục tiêu quan trọng của kiểm thử, nên điểm thưởng sẽ được ưu tiên hơn cho nhóm này. Tuy nhiên, việc xảy ra nhiều phản hồi của một hoạt động nhưng vẫn biểu thị cùng một lỗi không đóng góp đáng kể vào quá trình kiểm thử. Vì vậy, giải pháp sẽ tránh lặp lại cùng một lỗi xuất hiện nhiều lần.

Tiêu chí đánh giá sự khác biệt giữa hai phản hồi cần được xem xét một cách chi tiết và hệ thống. Đầu tiên, khi nội dung phản hồi là stack trace của lỗi \texttt{5xx}, nội dung stack trace sẽ được so sánh để xác định sự tương đồng. Hai stack trace được coi là giống nhau nếu chúng hoàn toàn trùng khớp về nội dung. Đối với phản hồi dưới dạng HTML, việc so sánh cấu trúc cây DOM của hai trang HTML là cần thiết. Hai trang HTML được coi là khác nhau nếu cấu trúc của hai cây DOM khác biệt. Tương tự, khi nội dung phản hồi có dạng JSON, cấu trúc của hai đối tượng JSON sẽ được so sánh. Hai đối tượng JSON được coi là khác nhau nếu có sự khác biệt về độ sâu, số lượng trường dữ liệu, hoặc tên các khóa (key) trong các trường dữ liệu. Cuối cùng, đối với nội dung phản hồi có dạng chuỗi ký tự, sự khác biệt về số từ trong chuỗi sẽ được coi là tiêu chí để đánh giá hai chuỗi khác nhau. Mỗi phương pháp phân loại này đảm bảo rằng các tiêu chí đánh giá sự khác biệt giữa hai phản hồi đều được thực hiện một cách chính xác và toàn diện, giúp cải thiện độ chính xác trong quá trình phân tích và xử lý dữ liệu.














\subsection{Mở rộng và tinh chỉnh nguồn sinh dữ liệu cho công cụ ARAT-RL}
\subsubsection{Sửa đổi nguồn sinh dữ liệu ngẫu nhiên}
Hiện tại, công cụ ARAT-RL sử dụng thư viện tích hợp của Python để sinh dữ liệu ngẫu nhiên. Mặc dù thư viện này tiện dụng, nhưng nó bộc lộ một số hạn chế. Đầu tiên, thư viện sử dụng các thuật toán PRNGs (Pseudo Random Number Generators) để tạo các số ngẫu nhiên. Điều này có nghĩa là các số được tạo ra có vẻ ngẫu nhiên nhưng thực chất dựa trên giá trị hạt giống (seed) ban đầu, do đó không thực sự ngẫu nhiên. Thêm vào đó, một số hàm trong thư viện có thể tạo ra các số không phân bố đều trên toàn phạm vi, dẫn đến phân bố không đồng đều. Cuối cùng, thuật toán PRNGs có khả năng lặp lại cao vì bị ảnh hưởng bởi giá trị hạt giống ban đầu, có thể sinh ra chuỗi số giống nhau, làm giảm tính ngẫu nhiên của dữ liệu.



Để giải quyết những hạn chế này, giải pháp đề xuất là thay thế thư viện hiện tại bằng việc sử dụng thư viện bên thứ ba. Giải pháp lựa chọn sử dụng Hypothesis, một thư viện kiểm thử mờ mạnh mẽ có chức năng sinh dữ liệu cho các ca kiểm thử \cite{hypothesis2016}. Việc sử dụng Hypothesis không chỉ giúp cải thiện tính ngẫu nhiên thực sự của dữ liệu mà còn được kỳ vọng tăng độ phủ trong quá trình kiểm thử. Trong bối cảnh các yêu cầu kiểm thử ngày càng phức tạp và đa dạng, việc áp dụng các công cụ mạnh mẽ như Hypothesis là cần thiết để đảm bảo chất lượng và hiệu quả của quá trình kiểm thử. Hypothesis không chỉ giải quyết các vấn đề hiện tại mà còn chuẩn bị cho ARAT-RL khả năng ứng phó với các thách thức kiểm thử trong tương lai.



\subsubsection{Thêm nguồn sinh dữ liệu dựa trên việc biến đổi các giá trị thành công trước đó}
Những yêu cầu được thực hiện thành công luôn mang ý nghĩa quan trọng trong kiểm thử. Khi một yêu cầu được thực hiện thành công, điều này cho thấy dữ liệu được gửi đi trong yêu cầu đó hoạt động chính xác và tuân thủ các quy tắc của hệ thống. Lưu trữ và biến đổi dữ liệu này không chỉ tăng tốc độ phát hiện lỗi mà còn có khả năng tìm ra các lỗi mới. Dựa trên ý tưởng này, giải pháp đã xây dựng một nguồn sinh dữ liệu mới, biến đổi dữ liệu từ các yêu cầu thành công trước đây.

Việc biến đổi dữ liệu ở đây nhằm mục đích sinh dữ liệu không tuân theo đặc tả. Giải pháp được đề xuất gồm hai phương pháp: tạo dữ liệu không đúng với mô tả của các trường dữ liệu trong đặc tả hoặc loại bỏ một số trường dữ liệu bắt buộc trong lược đồ tham số. Phương pháp được sử dụng sẽ được lựa chọn một cách ngẫu nhiên.

Với phương pháp tạo dữ liệu không tuân theo mô tả, giải pháp thực hiện duyệt qua từng trường dữ liệu trong lược đồ. Việc quyết định thực hiện biến đổi trường dữ liệu được phụ thuộc vào một số ngẫu nhiên. Nếu số ngẫu nhiên lớn hơn hằng số $mutation\_rate$ đã được định nghĩa.,
giải pháp  sẽ  tiến hành biến đổi. Giải pháp ở đây trình bày hai cách tạo dữ liệu không tuân theo đặc tả: thay đổi kiểu dữ liệu của trường dữ liệu mục tiêu hoặc tạo dữ liệu vượt quá các ràng buộc của trường dữ liệu. Việc đổi kiểu dữ liệu giúp kiểm tra tính linh hoạt và khả năng xử lý của hệ thống đối với các kiểu dữ liệu khác nhau.
Ngoài ra, việc sinh dữ liệu ngẫu nhiên nằm ngoài ràng buộc của trường dữ liệu cũng là một chiến lược quan trọng. Dữ liệu này có thể không tuân thủ hoàn toàn các quy tắc đã được định nghĩa trước, nhằm mục đích kiểm tra xem cách hệ thống phản ứng với các giá trị bất ngờ hoặc không hợp lệ.

Với phương pháp loại bỏ một số trường dữ liệu, giải pháp loại bỏ ngẫu nhiên một số các trường dữ liệu cần có được mô tả trong lược đồ. Bằng cách loại bỏ các trường dữ liệu, ta có thể mô phỏng các tình huống thực tế trong đó dữ liệu có thể bị thiếu sót hoặc không đầy đủ do nhiều nguyên nhân khác nhau như lỗi nhập liệu, truyền tải dữ liệu bị gián đoạn, hoặc nguồn dữ liệu không chính xác. Những biến đổi này giúp tạo ra các
kịch bản kiểm thử phức tạp hơn, đảm bảo rằng hệ thống có thể xử lý nhiều loại
tình huống khác nhau.






% \section{Tổng kết chương}


% Chương 3 trình bày hướng tiếp cận và thiết kế cho Phương pháp đánh giá điểm thưởng được trình bày trong chương này tập trung
% vào việc tối ưu hóa mức độ phủ của bài toán kiểm thử API, đồng thời đảm bảo
% tính hiệu quả và toàn diện trong quá trình đánh giá. Để đạt được mục tiêu này,
% phương pháp đề xuất xét đến nhiều khía cạnh quan trọng khác nhau của API và
% quá trình kiểm thử. Bên cạnh đó, chương này cũng trình bày về việc mở rộng và
% tinh chỉnh nguồn sinh dữ liệu mới cho công cụ, dựa trên việc khai thác thông tin
% thu thập trong quá trình kiểm thử.




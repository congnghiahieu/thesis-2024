\section{Hạn chế}

\begin{itemize}
    \item Ví dụ 1 loại nút AST -> 1 loại nút CPG. 100\% loại nút AST -> 1 loại nút CPG tương ứng
    \item Tuy nhiên cần phải xem xem nút CPG đó có giàu thông tin hay không
    \item Cái được cung cấp chỉ là AST. Ví dụ đối với C/C++ của Joern sử dụng CDT rất mạnh nên có nhiều thông tin hơn AST, ví dụ 1 nút AST có kèm luôn cả đoạn code tương ứng. Nhưng với TH này của Rust thì không có thư viện syn không có thông tin đoạn code tương ứng, thậm chí không có số dòng số cột, chỉ có cấu trúc cây AST. Riêng phần đoạn code là phải cấu tạo lại từ cây AST, và cũng chưa cấu tạo lại được hết tất cả các trường hợp.
\end{itemize}

\subsection{Macro}

Trong các ngôn ngữ lập trình như C/C++ và Rust có tính năng macro hay meta-programming, là cách viết mã nguồn để sinh ra mã nguồn khác.
Macro trong Rust bao gồm 2 loại declarative macro và procedural macro.
Declarative macro giống như macro trong C/C++, còn procedural macro giống như inline function.
Đối C/C++ có preprossor để xử lý macro trước khi cho vào trình biên dịch, đo đó khi mã nguồn sau khi được tiền xử lý thì đã được xử lý toàn bộ macro.
Tuy nhiên, Rust không giống C/C++, macro của Rust \cite{rustlangMacrosRust} không được xử lý ở trước khi sinh cây AST mà sẽ được xử lý sau khi sinh cây AST nhưng trước khi đi vào pha phân tích ngữ cảnh của trình biên dịch.
Như đã đề cập ở phần các trước, công cụ hiện tại sử dụng thư viện syn để sinh cây AST cho mã nguồn và syn không hỗ trợ xử lý macro.
Do đó tất cả các mã lệnh nằm bên trong macro sẽ không được xử lý, dẫn đến việc không thể sinh cây AST cho đoạn mã lệnh sử dụng macro.
Tất cả các đoạn lệnh nằm trong một lời gọi macro hiện tại được xem như một chuỗi ký tự.
Không chỉ vậy macro trong Rust sử dụng DSL (Domain-Specific Language) riêng, DSL này gần với ngôn ngữ Rust nhưng có sự mở rộng biến đổi để phù hợp với vai trò macro, do đó không thể sinh cây AST cho macro.

Để xử lý trường hợp trên, một bước tiền xử lý mã nguồn có thể được thêm vào để mở rộng macro như C/C++.
Công cụ có thể sử dụng đến thư viện \texttt{cargo-expand}, thư viện này có tác dụng đưa đoạn mã macro mà lập trình viên nhìn thấy thành đoạn mã mà trình biên dịch nhìn thấy.
Mã nguồn sau khi được mở rộng thì sẽ có được các thông tin bị ẩn đi như \texttt{prelude} mặc định của Rust bao gồm các hàm, các ký tự được nạp sẵn trong ngôn ngữ, các macro sẽ được mở rộng, bao gồm cả declarative và procedural macro.
Đối với declarative macro, thì macro nạp sẵn của ngôn ngữ như \texttt{println!}, \texttt{vec!} hay kể cả declarative macro do người dùng định nghĩa cũng sẽ được xử lý.
Tuy nhiên, việc mở rộng macro trước khi cho vào cây AST sẽ làm cho mã nguồn bị biến đổi so với mã nguồn gốc, đồng thời tăng kích cỡ và độ lớn của mã nguồn.
Việc thêm các thông tin ẩn mà lập trình viên không nhìn thấy có thể gây nhầm lẫn.
Điều này cũng đồng nghĩa với việc việc sinh cây AST cho mã nguồn sau khi xử lý macro sẽ phức tạp và tốn nhiều thời gian hơn.

\subsection{Module}

Cơ chế module trong Rust tương ứng với namespace trong C++, package trong Java.
Module chia nhỏ mã nguồn thành các phần nhỏ hơn, tổ chức và quản lý mã nguồn, giúp tái sử dụng mã nguồn, giúp tránh xung đột tên biến, hàm giữa các module khác nhau.
Một module trong Rust có thể là một file riêng biệt hoặc một phần của một file khác.
Các module có thể được tổ chức thành một hệ thống phân cấp, với các module con được khai báo bên trong các module cha.
% Có một số file được coi là file đặc biệt trong cấu trúc mã nguồn trong rust.
% Ví dụ như file mod.rs, đây là file module gốc của thư mục chứa nó, tất cả các module con trong thư mục đó sẽ được import thông qua module gốc mod.rs.
% Ngoài ra còn có file main.rs, lib.rs để đánh dấu điểm đầu vào của chương trình và xác định xem dự án là một thư viện hay một ứng dụng.
Rust còn cung cấp cơ chế workspace, cho phép quản lý nhiều dự án nhỏ trong cùng một dự án lớn, mỗi dự án là một thư mục con trong thư mục workspace.
Để kiểm soát khả năng truy cập, Rust sử dụng cơ chế visibility.
Mặc định các thành phần trong module là private, để làm cho chúng có thể truy cập được từ các module khác, ta sử dụng từ khóa \texttt{pub}.
Cơ chế path resolution dùng để định danh một thành phần cấu trúc từ module khác ta mà ta có thể import.
Path resolution có thể là đường dẫn tuyệt đối hoặc tương đối.
Ví dụ dùng từ khóa \texttt{self} để chỉ tới module hiện tại, dùng từ khóa \texttt{super} để chỉ tới module cha của module hiện tại, \texttt{crate} để chỉ tới module gốc của dự án.
Hệ thống module phức tạp của Rust làm tăng đáng kể độ khó việc xử lý quan hệ giữa các module trong cây AST và phân tích ngữ cảnh.
Việc xử lý các khái niệm như module con, module gốc, visibility, import và path resolution đòi hỏi một cơ chế phân tích tinh vi, do vậy hiện tại công cụ chưa xử lý được module.

% \subsection{Path}

% \begin{itemize}
%     \item Path có thể là Absolute Path hoặc Relative Path tùy vào bối cảnh module hiện tại, path có thể chỉ tới đối tượng trong cùng một module hoặc khác module
%     \item Path trong Rust là đường dẫn đến một đối tượng nào đó được định nghĩa trong mã nguồn như struct, trait, static, const, function
%     \item Cây AST sử dụng thư viện $syn$, $syn$ có thể lấy được path của một đối tượng nhưng không biết được đối đượng đang trỏ tới là static, const, hay function.
% Do đó đang không phân biệt được đâu là path của static, const, hay function
% \end{itemize}

% \subsection{Type Argument match Type Parameter}
